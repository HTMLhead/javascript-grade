# 객체 그리고 배열탐색

- ### 객체

  - `key` `value` 구조의 자료구조
  - JavaScript 기준으로는 `Array` `Object` 를 사용
  - `set` `map` 와 같은 자료구조가 나오고 있지만
    - 웹 브라우저의 지원이 부족한 상황
  - Object 형태는 `{ }` 로 자료를 표현
  - 서버와 클라이언트 간 데이터를 교환할 때
    - Object 포맷과 비슷한 방법으로 데이터를 보냄



- ### 객체 선언

  ```javascript
  const obj = {name : "crong", age : 20}
  ```

  - [참고사이트](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects#%EA%B0%9D%EC%B2%B4_%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0)

    - ### 객체 생성하기

      - JavaScript 에는 미리 정의된 객체가 존재

      - 사용자가 추가적인 객체 생성이 가능

      - **객체 이니셜라이저(initializer)** 을 이용하여 객체를 생성

      - 생성자 함수를 정의한 후

        - 함수와 `new 연산자`를 이용하여 인스턴스를 만들 수 있음

      - #### 객체 이니셜라이저

        - 생성자 함수 대신 사용
        - 리터럴 표기에 의한 객체 생성 (creating objects with literal notation)
        - C++ 에서도 비슷한 의미로 사용

        ```javascript
        var obj = { property_1:   value_1,   // property_# may be an identifier...
                    2:            value_2,   // or a number...
                    // ...,
                    "property n": value_n }; // or a string 
        ```

        - `obj` : 새로 만들어질 객체 이름
        - `property_1` : 식별자 (이름, 숫자 또는 스트링 리터럴)
        - `value_i` : 수식 - `property_i` 에 할당됨
          - 다른 곳에서 참조할 필요가 없으면, 변수에 할당하지 않아도 됨
        - 객체 이니셜라이저 : 수식
        - 이니셜라이저 수식에 의해 새로운 객체가 하나씩 생성됨
        - 똑같은 이니셜라이저에 의해 생성된 객체라도 서로 별개
          - 비교 결과는 동일하지 않음 `Not Equal`
        - `new Object()` 호출이 실행된 것 처럼 생성됨
        - 객체 이니셜라이저 수식에 의해 생성된 객체 = `Object`의 인스턴스

        ```javascript
        if (cond) var x = {hi: "there"};
        ```

        - 수식 `cond` 이 참일 경우
          - 객체를 만들고
          - 변수 `x`에 할당

        ```javascript
        var myHonda = {color: "red", wheels: 4, engine: {cylinders: 4, size: 2.2}};
        ```

        - `myHonda` 생성

        - 3개의 속성 추가

        - `engine` 역시 자신의 속성들을 가지고 있는 객체

        - [배열 역시 만들 수 있음](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values%2C_variables%2C_and_literals#Array_literals)

          ```javascript
          var coffees = ["French Roast", "Colombian", "Kona"];
          ```

          ```javascript
          var fish = ["Lion", , "Angel"];
          ```

          - 중간의 공백은 `undefined` 를 만듬
            - fish[0] = Lion
            - fish[1] = undefined
            - fish[2] = Angel
          - 후행 쉼표는 무시됨

  - JSON : 서버와 웹브라우저 간 데이터를 주고받을 때 정의한 포맷

  - [JSON Example](http://json.org/example.html)



- ### 객체의 추가/삭제

  ```javascript
  var myFriend = {key : "value", addition : [
          {name : 'codesquard'}, {age : 2}
      ]};

  console.log(myFriend.addition[0].name); // codesquard
  ```

  ```javascript
  for (value in myFriend) {
      console.log(value);
  }

  output
  key
  addition
  ```

  ```javascript
  const myFriend = {key : "value"};
  console.log(myFriend.key); // key에 따른 value 값 출력

  myFriend.age = 34; // 추가
  console.log(myFriend.age); // 추가된 부분 출력
  ```

  ​


- ### 객체의 탐색

  - for in

    ```javascript
    var myFriend = {key : "value", addition : [
            {name : 'codesquard'}, {age : 2}
        ]};
        
    for (key in myFriend) {
        console.log(myFriend[key]);
    } // [ { name: 'codesquard' }, { age: 2 } ]
    ```

  - Object.keys()

    ```javascript
    var myFriend = {key : "value", addition : [
            {name : 'codesquard'}, {age : 2}
        ]};

    console.log(Object.keys(myFriend)); // [ 'key', 'addition' ]
    Object.keys(myFriend).forEach(value => console.log(myFriend[value]));
    // [ { name: 'codesquard' }, { age: 2 } ]
    ```



- ### 핵심 개념

  ```
  for Each, map, filter, immutable
  ```

  - 데이터 조작을 위한 메서드들을 기억하는 것이 중요함
  - Single Page (?) 때문에 프론트엔드에서 처리하는 과정이 많아짐

  1. ### for vs forEach

     ```javascript
     var data = [{title : "hello", content : "간지철철", price},
     			{title : "crong", content : "괜춘한 상품", price : 5500},
     			{title : "codesquard", content : "쩌는 상품", price : 1200}];

     data.forEach(v => console.log(v.title, v.content));

     // hello 간지철철
     // crong 괜춘한 상품
     // codesquard 쩌는 상품
     ```

     - forEach 의 장점
       - i++ 이나 length 를 판단하는 코드가 필요 없음
       - 실수를 줄일 수 있고
       - 코드 가독성이 높아짐
     - ES6의 `arrow 함수(=>)`를 사용하면 더 간단해짐

  2. ### map, filter

     - 함수에서 정의한 방법대로 모든 원소를 가공
     - 새로운 배열을 반환

     ```javascript
     var filteredData = data.map(function(v) {
         return v * 1.1; // 10% 가격인상
         else return v;
     })
     ```

     - filter 메서드는 함수에서 정의한 조건에 맞는 원소만 추려서

     - 새로운 배열을 반환

       ```javascript
       var newData = data.map(function(v) {
           return v.price * 1.1;
       }) // [ 13200.000000000002, 6050.000000000001, 1320 ]
       ```

       ```javascript
       var newData = data.map(function(v) {
           var obj = {name : v.title, content : v.content, price : v.price * 10};
       });
       ```

       ```javascript
       console.table(data);
       console.table(newData);
       ```

     ```javascript
     var filteredData = data.filter(function(v) {
       return v.price > 5000; // 5000원 이상만 추출
     })
     ```

     ```javascript
     var filteredData = data.filter(function(v) {
       return v.price > 5000; // 5000원 이상만 추출
     }).map(function(v) {
        var obj = {title : v.title, content : v.content, price : v.price+""}; 
     });
     ```

     - 뒤에 `""` 를 붙여주면 문자열로 변환됨

  3. ### 추가 사항

     - forEach, map, filter 능숙해지기
     - array reduce 알아보기
     - 돈에 콤마 붙여보기
     - 원도 붙여보기
     - 함수형 프로그래밍


- ### 실습 1

  - 아래 데이터를 [확인](https://git.io/vQ2UR)해봅니다
  - 숫자 타입으로만 구성된 요소를 뽑아 배열을 만들어보도록 해보세요

  ```javascript
  //실행결과
  ["width", "height", "hOffset", "vOffset", "size", "hOffset", "vOffset"]
  ```

  ```javascript
  const widget = {
      "debug": "on",
      "window": {
          "title": "Sample Konfabulator Widget",
          "name": "main_window",
          "width": 500,
          "height": 500
      },
      "image": {
          "src": "Images/Sun.png",
          "name": "sun1",
          "hOffset": 250,
          "vOffset": 250,
          "alignment": "center"
      },
      "text": {
          "data": "Click Here",
          "size": 36,
          "style": "bold",
          "name": "text1",
          "hOffset": 250,
          "vOffset": 100,
          "alignment": "center",
          "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
      }
  }

  var result = [];

  for (key in widget) {
      // console.log(widget[key]);
      for (key2 in widget[key]) {
          // console.log(key2);
          // console.log(widget[key][key2]);
          if(typeof(widget[key][key2]) === "number") {
              result.push(key2);
              // console.log(key2);
          }
      }
      // console.log("---");
  }

  // console.log(result);

  console.log(result);

  // for (index in result) {
  //     console.log(result[index]);
  // }
  ```

  ​

- ### 실습2

  - [링크](https://git.io/vQukL)를 눌러서 데이터를 확인
  - type이 sk인, name으로 구성된 배열만 출력해본다

  ```

  ```

  ​







































